---
tags:
  - interview-prep
---
## Index 
- [[#1.0 Why this roadmap?|1.0 Why this roadmap?]]
- [[#2.0 Data Structures and Algorithms|2.0 Data Structures and Algorithms]]
	- [[#2.0 Data Structures and Algorithms#2.1 Pre-requisites|2.1 Pre-requisites]]
	- [[#2.0 Data Structures and Algorithms#2.2 Arrays|2.2 Arrays]]
		- [[#2.2 Arrays#2.2.1 Traversal and Basic Manipulation|2.2.1 Traversal and Basic Manipulation]]
		- [[#2.2 Arrays#2.2.2 N-Pointers|2.2.2 N-Pointers]]
		- [[#2.2 Arrays#2.2.3 Sliding Window|2.2.3 Sliding Window]]
		- [[#2.2 Arrays#2.2.4 Prefix Sum and Difference Arrays|2.2.4 Prefix Sum and Difference Arrays]]
		- [[#2.2 Arrays#2.2.5 Max and Min Subarray Patterns|2.2.5 Max and Min Subarray Patterns]]
		- [[#2.2 Arrays#2.2.6 Sorting + Partitioning Patterns|2.2.6 Sorting + Partitioning Patterns]]
		- [[#2.2 Arrays#2.2.7 Binary Search on Arrays|2.2.7 Binary Search on Arrays]]
		- [[#2.2 Arrays#2.2.8 Rearrangement, Duplicates, Cyclic Sort|2.2.8 Rearrangement, Duplicates, Cyclic Sort]]
		- [[#2.2 Arrays#2.2.9 Advanced Matrix Handling (2D Arrays)|2.2.9 Advanced Matrix Handling (2D Arrays)]]
		- [[#2.2 Arrays#2.2.10 Special Mentions|2.2.10 Special Mentions]]
	- [[#2.0 Data Structures and Algorithms#2.3 Linked Lists|2.3 Linked Lists]]
		- [[#2.3 Linked Lists#2.3.1 Basics and Traversal|2.3.1 Basics and Traversal]]
		- [[#2.3 Linked Lists#2.3.2 Two Pointers (Fast & Slow)|2.3.2 Two Pointers (Fast & Slow)]]
		- [[#2.3 Linked Lists#2.3.3 Reversal Techniques|2.3.3 Reversal Techniques]]
		- [[#2.3 Linked Lists#2.3.4 Merge and Sort Operations|2.3.4 Merge and Sort Operations]]
		- [[#2.3 Linked Lists#2.3.5 Deletion and Manipulation|2.3.5 Deletion and Manipulation]]
		- [[#2.3 Linked Lists#2.3.6 Cloning and Deep Copies|2.3.6 Cloning and Deep Copies]]
		- [[#2.3 Linked Lists#2.3.7 Advanced Structural Problems|2.3.7 Advanced Structural Problems]]
		- [[#2.3 Linked Lists#2.3.8 Circular and Doubly Linked Lists (Special Cases)|2.3.8 Circular and Doubly Linked Lists (Special Cases)]]
		- [[#2.3 Linked Lists#2.3.9 Design Applications|2.3.9 Design Applications]]
		- [[#2.3 Linked Lists#2.3.10 Special Mentions|2.3.10 Special Mentions]]
		- [[#2.3 Linked Lists#2.3.11 Math-Based Linked List Operations|2.3.11 Math-Based Linked List Operations]]
	- [[#2.0 Data Structures and Algorithms#2.4 Stacks and Queues|2.4 Stacks and Queues]]
		- [[#2.4 Stacks and Queues#2.4.1 Stack Fundamentals|2.4.1 Stack Fundamentals]]
		- [[#2.4 Stacks and Queues#2.4.2 Validity Checking Patterns|2.4.2 Validity Checking Patterns]]
		- [[#2.4 Stacks and Queues#2.4.3 Monotonic Stack Patterns|2.4.3 Monotonic Stack Patterns]]
		- [[#2.4 Stacks and Queues#2.4.4 Min/Max Stack Variants|2.4.4 Min/Max Stack Variants]]
		- [[#2.4 Stacks and Queues#2.4.5 Backtracking and Undo Stack|2.4.5 Backtracking and Undo Stack]]
		- [[#2.4 Stacks and Queues#2.4.6 Queue Fundamentals|2.4.6 Queue Fundamentals]]
		- [[#2.4 Stacks and Queues#2.4.7 Monotonic Queue & Sliding Window|2.4.7 Monotonic Queue & Sliding Window]]
		- [[#2.4 Stacks and Queues#2.4.8 Design Problems with Queue|2.4.8 Design Problems with Queue]]
		- [[#2.4 Stacks and Queues#2.4.9 Priority Queue (Heap-backed)|2.4.9 Priority Queue (Heap-backed)]]
		- [[#2.4 Stacks and Queues#2.4.10 Special Mentions|2.4.10 Special Mentions]]
	- [[#2.0 Data Structures and Algorithms#2.5 Trees and Binary Search|2.5 Trees and Binary Search]]
		- [[#2.5 Trees and Binary Search#2.5.1 Tree Fundamentals and Traversals|2.5.1 Tree Fundamentals and Traversals]]
		- [[#2.5 Trees and Binary Search#2.5.2 Binary Search Tree (BST) Patterns|2.5.2 Binary Search Tree (BST) Patterns]]
		- [[#2.5 Trees and Binary Search#2.5.3 Binary Tree Recursion Patterns|2.5.3 Binary Tree Recursion Patterns]]
		- [[#2.5 Trees and Binary Search#2.5.4 Tree Construction and Serialization|2.5.4 Tree Construction and Serialization]]
		- [[#2.5 Trees and Binary Search#2.5.5 Binary Search Patterns (On Arrays)|2.5.5 Binary Search Patterns (On Arrays)]]
		- [[#2.5 Trees and Binary Search#2.5.6 Binary Search on Monotonic Functions|2.5.6 Binary Search on Monotonic Functions]]
		- [[#2.5 Trees and Binary Search#2.5.7 Segment Trees and Advanced Structures|2.5.7 Segment Trees and Advanced Structures]]
		- [[#2.5 Trees and Binary Search#2.5.8 N-ary Trees and Generalized Trees|2.5.8 N-ary Trees and Generalized Trees]]
		- [[#2.5 Trees and Binary Search#2.5.9 Tree to Graph Transitions|2.5.9 Tree to Graph Transitions]]
		- [[#2.5 Trees and Binary Search#2.5.10 Special Mentions|2.5.10 Special Mentions]]
	- [[#2.0 Data Structures and Algorithms#2.6 Graphs|2.6 Graphs]]
		- [[#2.6 Graphs#2.6.1 Graph Traversals|2.6.1 Graph Traversals]]
		- [[#2.6 Graphs#2.6.2 Directed Graphs and Topological Sort|2.6.2 Directed Graphs and Topological Sort]]
		- [[#2.6 Graphs#2.6.3 Undirected Graphs and Cycle Detection|2.6.3 Undirected Graphs and Cycle Detection]]
		- [[#2.6 Graphs#2.6.4 Shortest Path Algorithms|2.6.4 Shortest Path Algorithms]]
		- [[#2.6 Graphs#2.6.5 MST and Spanning Trees|2.6.5 MST and Spanning Trees]]
		- [[#2.6 Graphs#2.6.6 Grid-Based Graphs|2.6.6 Grid-Based Graphs]]
		- [[#2.6 Graphs#2.6.7 Backtracking and Constraint Solving on Graphs|2.6.7 Backtracking and Constraint Solving on Graphs]]
		- [[#2.6 Graphs#2.6.8 Advanced Graph Topics|2.6.8 Advanced Graph Topics]]
	- [[#2.0 Data Structures and Algorithms#2.7 Heaps and Greedy|2.7 Heaps and Greedy]]
		- [[#2.7 Heaps and Greedy#2.7.1 Priority Queue Essentials|2.7.1 Priority Queue Essentials]]
		- [[#2.7 Heaps and Greedy#2.7.2 Top-K Patterns|2.7.2 Top-K Patterns]]
		- [[#2.7 Heaps and Greedy#2.7.3 Greedy Interval Scheduling|2.7.3 Greedy Interval Scheduling]]
		- [[#2.7 Heaps and Greedy#2.7.4 Greedy with Sorting and Decision Making|2.7.4 Greedy with Sorting and Decision Making]]
		- [[#2.7 Heaps and Greedy#2.7.5 Greedy Proof Techniques|2.7.5 Greedy Proof Techniques]]
	- [[#2.0 Data Structures and Algorithms#2.8 Dynamic Programming|2.8 Dynamic Programming]]
		- [[#2.8 Dynamic Programming#2.8.1 1D DP|2.8.1 1D DP]]
		- [[#2.8 Dynamic Programming#2.8.2 2D DP|2.8.2 2D DP]]
		- [[#2.8 Dynamic Programming#2.8.3 DP with States|2.8.3 DP with States]]
		- [[#2.8 Dynamic Programming#2.8.4 DP with Choices and Backtracking|2.8.4 DP with Choices and Backtracking]]
		- [[#2.8 Dynamic Programming#2.8.5 Bitmask DP|2.8.5 Bitmask DP]]
		- [[#2.8 Dynamic Programming#2.8.6 Optimized DP Patterns|2.8.6 Optimized DP Patterns]]
	- [[#2.0 Data Structures and Algorithms#2.9 Tries and String Matching|2.9 Tries and String Matching]]
		- [[#2.9 Tries and String Matching#2.9.1 Trie Basics|2.9.1 Trie Basics]]
		- [[#2.9 Tries and String Matching#2.9.2 Compressed & Suffix Tries|2.9.2 Compressed & Suffix Tries]]
		- [[#2.9 Tries and String Matching#2.9.3 String Matching Algorithms|2.9.3 String Matching Algorithms]]
		- [[#2.9 Tries and String Matching#2.9.4 Word Dictionary & Variants|2.9.4 Word Dictionary & Variants]]
		- [[#2.9 Tries and String Matching#2.9.5 Regex and Wildcard Parsing|2.9.5 Regex and Wildcard Parsing]]
	- [[#2.0 Data Structures and Algorithms#2.10 Bit Manipulation|2.10 Bit Manipulation]]
		- [[#2.10 Bit Manipulation#2.10.1 Bitwise Fundamentals|2.10.1 Bitwise Fundamentals]]
		- [[#2.10 Bit Manipulation#2.10.2 XOR Patterns|2.10.2 XOR Patterns]]
		- [[#2.10 Bit Manipulation#2.10.3 Bitmasking|2.10.3 Bitmasking]]
		- [[#2.10 Bit Manipulation#2.10.4 Advanced Bit Tricks|2.10.4 Advanced Bit Tricks]]
	- [[#2.0 Data Structures and Algorithms#2.11 Math and Number Theory|2.11 Math and Number Theory]]
		- [[#2.11 Math and Number Theory#2.11.1 Number Properties|2.11.1 Number Properties]]
		- [[#2.11 Math and Number Theory#2.11.2 Modular Arithmetic|2.11.2 Modular Arithmetic]]
		- [[#2.11 Math and Number Theory#2.11.3 GCD / LCM and Euclid’s Algorithm|2.11.3 GCD / LCM and Euclid’s Algorithm]]
		- [[#2.11 Math and Number Theory#2.11.4 Combinatorics|2.11.4 Combinatorics]]
		- [[#2.11 Math and Number Theory#2.11.5 Base Conversions and Encodings|2.11.5 Base Conversions and Encodings]]
	- [[#2.0 Data Structures and Algorithms#2.12 Special Techniques and Misc Patterns|2.12 Special Techniques and Misc Patterns]]
		- [[#2.12 Special Techniques and Misc Patterns#2.12.1 Merge Intervals and Sweep Line|2.12.1 Merge Intervals and Sweep Line]]
		- [[#2.12 Special Techniques and Misc Patterns#2.12.2 Binary Search on Answer|2.12.2 Binary Search on Answer]]
		- [[#2.12 Special Techniques and Misc Patterns#2.12.3 Sliding Window + Monotonic|2.12.3 Sliding Window + Monotonic]]
		- [[#2.12 Special Techniques and Misc Patterns#2.12.4 Reservoir Sampling & Randomized|2.12.4 Reservoir Sampling & Randomized]]
		- [[#2.12 Special Techniques and Misc Patterns#2.12.5 Simulation and State Machines|2.12.5 Simulation and State Machines]]
		- [[#2.12 Special Techniques and Misc Patterns#2.12.6 Design + Iterator Patterns|2.12.6 Design + Iterator Patterns]]

---
### 1.0 Why this roadmap? 

This is a noob’s overview of how he prepared — because sometimes, keeping it simple, silly (KISS), is exactly what even the pros need.

>[!info]- 
>Words of Honour by the Author : No Pressure guys 


----
### 2.0 Data Structures and Algorithms 

#### 2.1 Pre-requisites 

- Complexity Analysis (Time and Space)
- Modular Arithmetic
- Bit-Manipulation (not that deep)
- Recursion (BackTracking, Divide and Conquet)
- Sorting Algorithms 
- Binary Search (has an entire set of problems of its own)
- Prefix Sums

--- 

#### 2.2 Arrays

Foundation for most algorithmic patterns — used for traversal, windowing, prefix computation, in-place manipulation, and searching/sorting optimisations.
##### 2.2.1 Traversal and Basic Manipulation 

1. Iteration Patterns 
2. In-place overwrites 
3. Avoid extra space
##### 2.2.2 N-Pointers 

1. Opposite Ends
2. Same Direction 
3. Kth smallest sum/ distance 
##### 2.2.3 Sliding Window 

1. Fixed Size 
2. Variable Size 
3. Monotonic Queue 
##### 2.2.4 Prefix Sum and Difference Arrays 

1. Prefix sum for subarray range
2. Prefix hash (char counts)
3. Difference array for range update tricks
##### 2.2.5 Max and Min Subarray Patterns 

1. Local vs Global Subarrays 
2. Restarting Subarrays 
3. Track best-so far 
##### 2.2.6 Sorting + Partitioning Patterns

1. Dutch National Flag
2. Wiggle sort
3. QuickSelect / Partition around pivot
##### 2.2.7 Binary Search on Arrays

1. Binary search in rotated array
2. First/last occurrence
3. Search on answer space (partitioned search space)

##### 2.2.8 Rearrangement, Duplicates, Cyclic Sort

1. In-place rearrangement
2. Cyclic sort to detect missing/misplaced

##### 2.2.9 Advanced Matrix Handling (2D Arrays)

1. Spiral traversal
2. Rotation in-place
3. Search in sorted matrix

##### 2.2.10 Special Mentions 

1. Kadane's Algo 
2. Merge Intervals 
3. Rainwater Trapping 
4. Inversions 
5. Next Permutations 
6. Moore's Voting (Majority element)
7. Floyd's Algorithm (Cycle Detection)
---
#### 2.3 Linked Lists

Fundamental pointer-based structure. Core to recursion, in-place manipulation, and memory management patterns.
##### 2.3.1 Basics and Traversal

1. Single and Doubly Linked Lists
2. Iterative vs Recursive Traversal
3. Handling nulls and one-node cases
##### 2.3.2 Two Pointers (Fast & Slow)

1. Cycle detection (Floyd’s algorithm)
2. Finding midpoint
3. Detecting palindrome in-place
##### 2.3.3 Reversal Techniques

1. Full reversal (iterative and recursive)
2. Partial reversal between `m` and `n`
3. Reverse in groups of K nodes
##### 2.3.4 Merge and Sort Operations

1. Merge two sorted lists
2. Merge K sorted lists (using heap)
3. Sort linked list (merge sort)
##### 2.3.5 Deletion and Manipulation

1. Delete N-th node from end
2. Delete given node (without head)
3. Remove duplicates
##### 2.3.6 Cloning and Deep Copies

1. Clone list with random pointer
2. HashMap-based vs O(1) interleaving method
##### 2.3.7 Advanced Structural Problems

1. Intersection of two lists
2. Detect start of cycle
3. Flatten multi-level linked list
4. Reorder list (alternate merge)
##### 2.3.8 Circular and Doubly Linked Lists (Special Cases)

1. Circular loop detection and breaking
2. DLL insert/delete patterns
3. Applications in LRU/Deque
##### 2.3.9 Design Applications

1. LRU Cache (DLL + HashMap)
2. Browser history (bi-directional navigation)
3. Music/Carousel queue rotation
##### 2.3.10 Special Mentions

1. Floyd’s Cycle Detection
2. Recursive reversal variations
3. In-place manipulation with pointer gymnastics
4. Dummy node patterns
##### 2.3.11 Math-Based Linked List Operations

1. Add two numbers (forward and reverse order)
2. Subtract two numbers (handle borrow cases)
3. Multiply two numbers (simulating digit-by-digit)
4. Convert linked list to number and back
5. Edge handling: carry, leading zeros, unequal lengths
---
#### 2.4 Stacks and Queues

Used to maintain temporal or order-based state. Common in parsing, monotonic operations, and backtracking patterns.

##### 2.4.1 Stack Fundamentals

1. LIFO principle and implementation via arrays or LL
2. Expression parsing and evaluation
3. Reversing structures

##### 2.4.2 Validity Checking Patterns

1. Valid parentheses/brackets
2. Minimum add to make valid
3. Remove invalid parentheses (generate all)

##### 2.4.3 Monotonic Stack Patterns

1. Next greater/smaller element
2. Nearest smaller to left/right
3. Histogram problems (max rectangle area)

##### 2.4.4 Min/Max Stack Variants

1. Stack with min in O(1)
2. Design stack with constant-time retrievals
3. Max Stack or Stack of Stacks

##### 2.4.5 Backtracking and Undo Stack

1. Evaluate Reverse Polish Notation
2. Path simplification (`../`, `./`)
3. Browser-like undo/redo patterns

##### 2.4.6 Queue Fundamentals

1. FIFO queue basics and circular queue
2. Implementation with 2 stacks
3. Multi-producer consumer simulation

##### 2.4.7 Monotonic Queue & Sliding Window

1. Sliding window max/min
2. 1D DP optimizations with queue (jump game, rotten oranges)
3. Using deque for state preservation

##### 2.4.8 Design Problems with Queue

1. Implement Stack using Queue
2. Implement Queue using Stack
3. LRU cache with deque
4. Moving average / time-based hit counter

##### 2.4.9 Priority Queue (Heap-backed)

1. Top K elements
2. Merge K sorted streams
3. Frequency sorting
4. Custom comparators

##### 2.4.10 Special Mentions

1. Stack of stacks
2. Balanced binary expression evaluator
3. Largest rectangle in histogram
4. Implement circular deque
5. Wait time problems (stock span, daily temps)
---
#### 2.5 Trees and Binary Search

Recursive hierarchical structures used in traversal-based problems, dynamic state management, and ordered data lookup. Binary Search leverages sorted structure or monotonic properties for O(log n) operations.

##### 2.5.1 Tree Fundamentals and Traversals

1. Inorder / Preorder / Postorder (recursive + iterative)
2. Level-order (BFS using queue)
3. DFS vs BFS trade-offs

##### 2.5.2 Binary Search Tree (BST) Patterns

1. Validate BST structure
2. Floor / Ceiling / Closest value
3. Kth smallest/largest element
4. Range queries in BST

##### 2.5.3 Binary Tree Recursion Patterns

1. Subtree checking and symmetry
2. Path sum variations (root-to-leaf, any-to-any)
3. Diameter and max depth
4. LCA (Lowest Common Ancestor)

##### 2.5.4 Tree Construction and Serialization

1. Build tree from inorder + preorder/postorder
2. Serialize/deserialize binary trees (DFS/BFS)
3. Flatten binary tree (in-place)

##### 2.5.5 Binary Search Patterns (On Arrays)

1. Standard binary search (left/right bounds)
2. First/last occurrence (duplicates allowed)
3. Search in rotated array
4. Search on answer space (e.g., min capacity to ship packages)

##### 2.5.6 Binary Search on Monotonic Functions

1. Find smallest/largest x such that f(x) is valid
2. Application in greedy/DP problems
3. Lower bound / upper bound logic

##### 2.5.7 Segment Trees and Advanced Structures

1. Range query/update (RMQ, RSQ)
2. Lazy propagation
3. Binary Indexed Tree (Fenwick Tree)

##### 2.5.8 N-ary Trees and Generalized Trees

1. Generic tree traversal (DFS/BFS)
2. M-ary trees, Trie basics
3. Folder/tree structure parsing

##### 2.5.9 Tree to Graph Transitions

1. Convert tree to graph for bidirectional traversal
2. BFS/DFS in tree-turned-undirected-graph

##### 2.5.10 Special Mentions

1. Morris Traversal (O(1) space inorder)
2. Tree diameter via post-order
3. Threaded trees
4. Binary lifting (ancestor queries)
5. Sparse tables

#### 2.6 Graphs

Graphs represent relationships and connectivity — foundational for traversal, search, cycles, and dependency resolution problems.

##### 2.6.1 Graph Traversals

1. BFS (level order, shortest path in unweighted)
2. DFS (recursion + stack)
3. Connected components

##### 2.6.2 Directed Graphs and Topological Sort

1. Kahn’s Algorithm (BFS)
2. DFS-based topo sort
3. Cycle detection in directed graphs

##### 2.6.3 Undirected Graphs and Cycle Detection

1. Union-Find / DSU
2. DFS with parent tracking
3. Bipartite check (BFS coloring)

##### 2.6.4 Shortest Path Algorithms

1. Dijkstra (min-heap based)
2. Bellman-Ford (negative weights)
3. A* Search (heuristics)

##### 2.6.5 MST and Spanning Trees

1. Prim’s Algorithm
2. Kruskal’s Algorithm
3. Disjoint Set Union applications

##### 2.6.6 Grid-Based Graphs

1. Word search, island count
2. Flood fill and BFS
3. Multi-source BFS (rotting oranges)

##### 2.6.7 Backtracking and Constraint Solving on Graphs

1. N-Queens
2. Sudoku
3. Hamiltonian Path (TSP, exhaustive)

##### 2.6.8 Advanced Graph Topics

1. Articulation points and bridges
2. Tarjan’s algorithm (SCC)
3. Top K shortest paths (Yen’s algorithm)

---

#### 2.7 Heaps and Greedy

Focus on local optimizations, interval processing, and frequency-based selection problems.

##### 2.7.1 Priority Queue Essentials

1. Min-heap / Max-heap basics
2. Custom comparators
3. Heapify and streaming

##### 2.7.2 Top-K Patterns

1. K largest/smallest elements
2. K frequent elements
3. K closest points/numbers

##### 2.7.3 Greedy Interval Scheduling

1. Activity selection
2. Meeting rooms
3. Merge intervals

##### 2.7.4 Greedy with Sorting and Decision Making

1. Task scheduling
2. Gas station / jump game
3. Minimum platforms

##### 2.7.5 Greedy Proof Techniques

1. Exchange argument
2. Staying ahead
3. Greedy-choice property

---

#### 2.8 Dynamic Programming

Captures overlapping subproblems and optimal substructure. Backbone of FAANG-hard problems.

##### 2.8.1 1D DP

1. Fibonacci, Climbing Stairs
2. House Robber
3. Coin Change

##### 2.8.2 2D DP

1. Longest common subsequence
2. Edit Distance
3. DP on grids

##### 2.8.3 DP with States

1. DP[i][j], DP[i][j][k] patterns
2. Buy/sell stock with cooldowns
3. Knapsack variations

##### 2.8.4 DP with Choices and Backtracking

1. Word Break
2. Palindrome Partitioning
3. Regex Matching

##### 2.8.5 Bitmask DP

1. Traveling salesman
2. Set cover
3. Subset state transitions

##### 2.8.6 Optimized DP Patterns

1. Space optimized DP
2. Monotonic queue optimization
3. Divide and conquer DP

---

#### 2.9 Tries and String Matching

Prefix trees and search algorithms used in autocomplete, substring search, and pattern parsing.

##### 2.9.1 Trie Basics

1. Insert/search/delete words
2. Prefix search
3. Auto-suggestion systems

##### 2.9.2 Compressed & Suffix Tries

1. Radix trie
2. Suffix trie
3. Suffix tree intro

##### 2.9.3 String Matching Algorithms

1. KMP (prefix table)
2. Rabin-Karp (hash rolling)
3. Z-algorithm

##### 2.9.4 Word Dictionary & Variants

1. Word search in board (DFS + Trie)
2. Word break I/II
3. Replace words in sentence

##### 2.9.5 Regex and Wildcard Parsing

1. Regex match with `.` and `*`
2. Wildcard `?` and `*` patterns
3. Backtracking + memoization combo

---

#### 2.10 Bit Manipulation

Low-level operations useful in optimization, XOR tricks, and subset processing.

##### 2.10.1 Bitwise Fundamentals

1. Set/unset/check/toggle bits
2. Shift operations
3. Bit count and masks

##### 2.10.2 XOR Patterns

1. Single number (odd frequency)
2. Pairwise XOR logic
3. Missing number, duplicate detection

##### 2.10.3 Bitmasking

1. Subset generation
2. Set cover and DP
3. Bitwise DP state compression

##### 2.10.4 Advanced Bit Tricks

1. Brian Kernighan’s algo
2. Lowest set bit
3. Divide/multiply using shifts

---

#### 2.11 Math and Number Theory

Used in constraints, simulations, hashing, combinatorics, and cryptographic edge cases.

##### 2.11.1 Number Properties

1. Prime number sieve
2. Perfect squares and roots
3. Palindromes, Armstrong, etc.

##### 2.11.2 Modular Arithmetic

1. Mod inverse
2. Modulo multiplication/division
3. Overflow prevention

##### 2.11.3 GCD / LCM and Euclid’s Algorithm

1. Standard GCD
2. Extended Euclidean Algorithm
3. LCM derivation

##### 2.11.4 Combinatorics

1. Factorials, nCr
2. Pascal’s Triangle
3. DP + combinatorics (unique paths, catalan)

##### 2.11.5 Base Conversions and Encodings

1. Decimal ↔ Binary/Hex/Base62
2. Excel column name ↔ Number
3. Custom radix encoding/decoding

---

#### 2.12 Special Techniques and Misc Patterns

Power tools and edge-case solvers that don't fit in a single category.

##### 2.12.1 Merge Intervals and Sweep Line

1. Merge/insert intervals
2. Meeting rooms
3. Line sweep problems (min overlap)

##### 2.12.2 Binary Search on Answer

1. Minimum feasible value (ship capacity, days)
2. Monotonic f(x)
3. Minimize/maximize result over decision space

##### 2.12.3 Sliding Window + Monotonic

1. Maximum in window
2. Min swaps to group elements
3. Longest subarray under sum/condition

##### 2.12.4 Reservoir Sampling & Randomized

1. Pick random element with unknown N
2. Shuffle array uniformly
3. Randomized hashing

##### 2.12.5 Simulation and State Machines

1. Game of life
2. Spiral matrix
3. Turing tape / DFA logic

##### 2.12.6 Design + Iterator Patterns

1. Nested Iterator
2. Zigzag iterator
3. Iterator for BST





